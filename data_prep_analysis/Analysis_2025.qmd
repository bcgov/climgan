---
title: "Analysis"
author: "Tirion"
format: html
editor: visual
---

```{python}
import torch
import numpy as np
import pandas as pd
import xarray as xr
from matplotlib import pyplot as plt
import torch.nn.functional as F
```

```{r}
library(terra)
library(reticulate)
library(data.table)
library(ggplot2)
library(matrixStats)
```

## Plot test metrics while model is training:

```{r}
# load data
test_metrics <- read.csv("C:/Users/TGRICE/Downloads/test_metrics.csv")

# plot MAE by epochs
epochs <- seq(0, 250, by=10)
plot(x = epochs, y = test_metrics[,2], xlab = "# of epochs", ylab = "MAE")

# plot Wasserstein distance by epochs
plot(x = epochs, y = test_metrics[,3], xlab = "# of epochs", ylab = "Wass. dist")
```

## Load data:

```{python}
pred_dir = 'O:/Mosaic_Yukon/Tirion/Results/Run5/GAN_gen250/'
pred_path = pred_dir + 'Run5_gen250_fullregion.nc'
truth_dir = 'C:/Users/TGRICE/OneDrive - Government of BC/Documents/GANs/PRISM/tmax/mar/'
truth_path = truth_dir + 'prism_train_coarse.nc' 

# load GAN predictions and true fields (PRISM) 
pred = xr.open_dataset(pred_path)
truth = xr.open_dataset(truth_path)

# crop truth to the size of pred if needed
#truth = truth.isel(longitude=slice(0,288))
```

## Prepare test data (truth):

```{python}
# unstandardizing the truth
stand = pd.read_csv(truth_dir + 'standardization.csv')
#stand

mean = stand['mean'][0]
std = stand['std'][0]
truth['tmax'] = (truth.tmax*std)+mean

# change pred longitude to degrees E to match truth
pred = pred.assign_coords(longitude=pred.longitude % 360)
```

## Plot difference between truth and prediction:

```{python}
# make torch tensors of fields to compute MAE
pred_np = np.array(pred.tmax)
truth_np = np.array(truth.tmax)

# mask out nans
mask = ~np.isnan(truth_np) & ~np.isnan(pred_np)
pred_valid = torch.from_numpy(pred_np[mask])
truth_valid = torch.from_numpy(truth_np[mask])


MAE = F.l1_loss(truth_valid.float(), pred_valid.float())
#print("MAE:", MAE.item())

# plotting truth, prediction, and difference (choose to save or not)
fig, ax = plt.subplots(1, 3, layout='constrained', figsize=(10, 5), sharex=True, sharey=True)

minmin = np.min(truth.tmax)
maxmax = np.max(truth.tmax)
# precip (30), temp max (3)
dmin = -10
dmax = 10

pc1 = ax[0].pcolormesh(truth.longitude, truth.latitude, truth.tmax, vmin=minmin, vmax=maxmax, cmap='viridis', label=r'$m$')
ax[0].set_title(f'truth', fontsize='medium', loc='center')
#ax[0].set_ylim(59, 71)

pc2 = ax[1].pcolormesh(pred.longitude, pred.latitude, pred.tmax, vmin=minmin, vmax=maxmax, cmap='viridis', label=r'$m$')
ax[1].set_title(f'prediction', fontsize='medium', loc='center')
#ax[1].set_ylim(59, 71)

pc3 = ax[2].pcolormesh(pred.longitude, pred.latitude, truth.tmax.values-pred.tmax.values, vmin=dmin, vmax=dmax, cmap='RdBu', label=r'$m$')
ax[2].set_title(f'truth-prediction', fontsize='medium', loc='center')
#ax[2].set_ylim(59, 71)

fig.supylabel('latitude [deg N]')
fig.supxlabel('longitude [deg E]')

fig.suptitle(f"March tmax, MAE = %.2f" %MAE)

fig.colorbar(pc1, shrink=0.5, aspect=20, location='bottom', ax=ax[0:2])
fig.colorbar(pc3, shrink=0.9, aspect=20, location='bottom', ax=ax[2])
plt.savefig(pred_dir + "pred_PRISM_test_diff_fullarea.png", dpi = 400)
plt.close()
```

## Plot maps (generated from pred & blending in Pred_2025.qmd):

Create raster:

```{python}
import matplotlib.patches as patches

final_pad = torch.load("O:/Mosaic_Yukon/Tirion/Results/Run4/GAN_gen250/Run4_gen250_fullregion.pt")

res_np = np.array(final_pad)

plt.close()
fig, ax = plt.subplots()
im = ax.imshow(res_np)
rect = patches.Rectangle((0, 0), 288, res_np.shape[0], linewidth=2, edgecolor='black', facecolor='none')
ax.add_patch(rect)
# cbar = plt.colorbar(im)
# pos = cbar.ax.get_position()
# new_height = pos.height * 0.5
# new_y = pos.y0 + (pos.height - new_height) / 2
# cbar.ax.set_position([pos.x0, new_y, pos.width, new_height])
ax.axis('off')
plt.savefig(pred_dir + "full_map.png", bbox_inches='tight', dpi=600)
plt.show()

res_np.shape
```

Plot w/ longitude & latitude:

```{r}
library(terra)
library(data.table)
library(reticulate)
library(RColorBrewer)

results_folder <- "O:/Mosaic_Yukon/Tirion/Results/Run2/GAN_gen250/"

#dem_test <- rast(paste(dem_folder, "dem_test_cropped.nc", sep = ""))

res <- dem[[1]]
rast_dim <- dim(res)
preds <- py$res_np
dim(preds)

preds <- preds[1:rast_dim[1],1:rast_dim[2]]
values(res) <- preds
plot(res)
# add rectangle of test area
xmax_box <- xmin(res) + 288*xres(res)
rect(
  xleft = xmin(res), 
  ybottom = ymin(res),
  xright = xmax_box, 
  ytop = ymax(res),
  border = "black", 
  lwd = 2
)

# save as png
png(paste0(results_folder, "full_map.png"), width = 1000, height = 600)
plot(res, asp = 1)
# add rectangle of test area
xmax_box <- xmin(res) + 288*xres(res)
rect(
  xleft = xmin(res), 
  ybottom = ymin(res),
  xright = xmax_box, 
  ytop = ymax(res),
  border = "black", 
  lwd = 2
)
dev.off()

# x <- read.csv(paste(data_folder, "standardization.csv", sep=""))
# 
# unstand_mean <- x[[3]][1]
# unstand_std <- x[[4]][1]
# 
# res_us <- (res * unstand_std) + (unstand_mean)
# plot(res_us)

# writeCDF(res, paste0(results_folder, "GAN_gen250_fullregion_sd.nc"), varname='tmax', overwrite = T)
```

## Calculate lag1 pixel-wise correlation:

```{python}
def lag1(x):
    """ Lag1 autocorrelation function for each pixel """
    if np.all(np.isnan(x)):
        return np.nan
    x_mean = np.nanmean(x)
    x0 = x[:-1] - x_mean
    x1 = x[1:] - x_mean
    return np.nansum(x0 * x1) / np.nansum(x0**2)
  
months = ["dec", "jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov"]

base_path = "C:/Users/TGRICE/OneDrive - Government of BC/Documents/GANs/PRISM/tmax"

datasets = []

for month in months:
    nc_path = f"{base_path}/{month}/prism_train_coarse.nc"
    csv_path = f"{base_path}/{month}/standardization.csv"

    ds = xr.open_dataset(nc_path)

    stand = pd.read_csv(csv_path)
    mean = stand['mean'][0]
    std = stand['std'][0]

    ds['tmax'] = (ds['tmax'] * std) + mean

    datasets.append(ds['tmax'])

data_wt = xr.concat(datasets[0:2], dim="time")
data_sp = xr.concat(datasets[3:5], dim="time")
data_sm = xr.concat(datasets[6:8], dim="time")
data_at = xr.concat(datasets[9:11], dim="time")

lag1_map_wt = xr.apply_ufunc(
    lag1,
    data_wt,
    input_core_dims=[["time"]],
    vectorize=True,
    output_dtypes=[float]
)

lag1_map_sp = xr.apply_ufunc(
    lag1,
    data_sp,
    input_core_dims=[["time"]],
    vectorize=True,
    output_dtypes=[float]
)

lag1_map_sm = xr.apply_ufunc(
    lag1,
    data_sm,
    input_core_dims=[["time"]],
    vectorize=True,
    output_dtypes=[float]
)

lag1_map_at = xr.apply_ufunc(
    lag1,
    data_at,
    input_core_dims=[["time"]],
    vectorize=True,
    output_dtypes=[float]
)

maps = [lag1_map_wt, lag1_map_sp, lag1_map_sm, lag1_map_at]
titles = ["Winter", "Spring", "Summer", "Autumn"]

fig, axes = plt.subplots(2, 2, figsize=(12, 10))
axes = axes.flatten()

for ax, data, title in zip(axes, maps, titles):
    data.plot(ax=ax, cmap="coolwarm", vmin=-1, vmax=1, add_colorbar=True)
    ax.set_title(title)
    ax.set_xticks([])
    ax.set_yticks([])

plt.tight_layout()
plt.show()
# writeCDF(res, paste0(results_folder, "GAN_gen250_fullregion_sd.nc"), varname='tmax', overwrite = T)
```

## Calculate pixel-wise difference:

```{python}
diffs = [datasets[i+1] - datasets[i] for i in range(len(datasets) - 1)]

labels = ["Feb-Jan", "Mar-Feb", "Apr-Mar", "May-Apr", "Jun-May", "Jul-Jun", "Aug-Jul", "Sep-Aug", "Oct-Sep", "Nov-Oct", "Dec-Nov"]

plt.close()
fig, axes = plt.subplots(3, 4, figsize=(28, 16))
axes = axes.flatten()

for ax, diff, label in zip(axes, diffs, labels):
    diff.plot(ax=ax, cmap='coolwarm', add_colorbar=True)
    ax.set_title(label, fontsize=12)
    ax.set_xticks([])  # remove x-axis ticks
    ax.set_yticks([])  # remove y-axis ticks
    ax.set_xlabel('')  # remove x-axis label
    ax.set_ylabel('')  # remove y-axis label

# Turn off the last empty subplot if grid > number of diffs
for ax in axes[len(diffs):]:
    ax.axis('off')

# Adjust spacing: more space between rows and columns
plt.subplots_adjust(hspace=0.5, wspace=0.75)

plt.show()
```
